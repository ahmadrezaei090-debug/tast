import React, { useState, useCallback, useEffect } from 'react';
import { generateImageFromText, generateImageFromImage } from './services/geminiService';
import { TEXT_TO_IMAGE_OPTIONS, UI_TEXTS, GAME_GENRE_OPTIONS } from './constants';
import type { TextToImageOptionKey, UploadedImage, TextToImageOptions, UserStats, HistoryItem } from './types';
import TabButton from './components/TabButton';
import SelectInput from './components/SelectInput';
import ImageUpload from './components/ImageUpload';
import Spinner from './components/Spinner';
import { ImageIcon, SparklesIcon, AlertTriangleIcon, GiftIcon, HistoryIcon } from './components/Icons';

type Mode = 'text-to-image' | 'image-to-image';
const DAILY_LIMIT = 5;

export default function App() {
  const [mode, setMode] = useState<Mode>('text-to-image');
  const [prompt, setPrompt] = useState<string>('');
  const [options, setOptions] = useState<TextToImageOptions>({
    purpose: TEXT_TO_IMAGE_OPTIONS.purpose.options[0].value,
    gameGenre: GAME_GENRE_OPTIONS.options[0].value,
    background: TEXT_TO_IMAGE_OPTIONS.background.options[0].value,
    angle: TEXT_TO_IMAGE_OPTIONS.angle.options[0].value,
    style: TEXT_TO_IMAGE_OPTIONS.style.options[0].value,
    aspectRatio: TEXT_TO_IMAGE_OPTIONS.aspectRatio.options[0].value as '1:1',
  });
  const [uploadedImage, setUploadedImage] = useState<UploadedImage | null>(null);
  const [generatedImage, setGeneratedImage] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const [history, setHistory] = useState<HistoryItem[]>([]);
  const [userStats, setUserStats] = useState<UserStats>({ count: 0, lastReset: Date.now(), credits: 0, unlimitedUntil: null });
  const [giftCode, setGiftCode] = useState('');
  const [giftCodeMessage, setGiftCodeMessage] = useState({ type: '', text: '' });


  // Load state from localStorage on mount
  useEffect(() => {
    try {
      const savedHistory = localStorage.getItem('aiImageGeneratorHistory');
      if (savedHistory) {
        setHistory(JSON.parse(savedHistory));
      }
      
      const savedStats = localStorage.getItem('aiImageGeneratorUserStats');
      if (savedStats) {
        const stats = JSON.parse(savedStats);
        // Check if a day has passed to reset the counter
        const now = Date.now();
        const lastReset = stats.lastReset || 0;
        if (now - lastReset > 24 * 60 * 60 * 1000) {
          stats.count = 0;
          stats.lastReset = now;
        }
        setUserStats(stats);
      }
    } catch (e) {
      console.error("Failed to load state from localStorage", e);
    }
  }, []);

  // Save state to localStorage on change
  useEffect(() => {
    try {
      localStorage.setItem('aiImageGeneratorHistory', JSON.stringify(history));
      localStorage.setItem('aiImageGeneratorUserStats', JSON.stringify(userStats));
    } catch (e) {
      console.error("Failed to save state to localStorage", e);
    }
  }, [history, userStats]);


  const handleOptionChange = (key: TextToImageOptionKey, value: string) => {
    setOptions(prev => ({ ...prev, [key]: value }));
  };

  const handleImageUpload = (file: File) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      setUploadedImage({
        file,
        base64: (reader.result as string).split(',')[1],
      });
    };
    reader.readAsDataURL(file);
  };
  
  const canGenerate = () => {
      const now = Date.now();
      if(userStats.unlimitedUntil && userStats.unlimitedUntil > now) {
          return true;
      }
      if(userStats.credits > 0) {
          return true;
      }
      if(userStats.count < DAILY_LIMIT) {
          return true;
      }
      return false;
  }

  const handleSubmit = useCallback(async () => {
    setError(null);
    if (!canGenerate()) {
        setError(UI_TEXTS.errorLimitReached);
        return;
    }
    
    setIsLoading(true);
    setGeneratedImage(null);

    try {
      let result: string | null = null;
      if (mode === 'text-to-image') {
        if (!prompt) {
          setError(UI_TEXTS.errorPromptRequired);
          setIsLoading(false);
          return;
        }
        result = await generateImageFromText(prompt, options);
      } else {
        if (!uploadedImage) {
          setError(UI_TEXTS.errorImageRequired);
          setIsLoading(false);
          return;
        }
        result = await generateImageFromImage(prompt, uploadedImage.base64);
      }
      setGeneratedImage(result);

      const newHistoryItem: HistoryItem = {
        id: `img-${Date.now()}`,
        imageUrl: result,
        prompt: prompt,
        options: options,
        timestamp: Date.now(),
      };
      setHistory(prev => [newHistoryItem, ...prev].slice(0, 50)); // Keep last 50 images

      // Update user stats
      setUserStats(prev => {
        const now = Date.now();
        if (prev.unlimitedUntil && prev.unlimitedUntil > now) {
            return prev; // No change for unlimited users
        }
        if (prev.credits > 0) {
            return { ...prev, credits: prev.credits - 1 };
        }
        return { ...prev, count: prev.count + 1 };
      });

    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : UI_TEXTS.errorGeneral);
      console.error(e);
    } finally {
      setIsLoading(false);
    }
  }, [mode, prompt, options, uploadedImage, userStats]);
  
  const handleRedeemCode = () => {
      let messageType = 'error';
      let messageText = UI_TEXTS.giftCodeInvalid;

      const code = giftCode.trim().toLowerCase();
      if (code === '10kopf') {
          setUserStats(prev => ({ ...prev, credits: prev.credits + 10 }));
          messageType = 'success';
          messageText = UI_TEXTS.giftCodeSuccess10;
      } else if (code === '30kpkf') {
          setUserStats(prev => ({ ...prev, credits: prev.credits + 30 }));
          messageType = 'success';
          messageText = UI_TEXTS.giftCodeSuccess30;
      } else if (code === '24kops') {
          setUserStats(prev => ({ ...prev, unlimitedUntil: Date.now() + 24 * 60 * 60 * 1000 }));
          messageType = 'success';
          messageText = UI_TEXTS.giftCodeSuccess24h;
      }
      
      setGiftCodeMessage({ type: messageType, text: messageText });
      setGiftCode('');
      setTimeout(() => setGiftCodeMessage({ type: '', text: '' }), 4000);
  };


  const isSubmitDisabled = isLoading || (mode === 'text-to-image' && !prompt) || (mode === 'image-to-image' && !uploadedImage);
  const remainingGenerations = () => {
      const now = Date.now();
      if (userStats.unlimitedUntil && userStats.unlimitedUntil > now) return 'نامحدود';
      const dailyRemaining = DAILY_LIMIT - userStats.count;
      return dailyRemaining + userStats.credits;
  }
  
  const optionKeysInOrder: TextToImageOptionKey[] = ['purpose', 'background', 'angle', 'style', 'aspectRatio'];


  return (
    <div className="bg-gray-900 text-white min-h-screen flex flex-col lg:flex-row p-4 gap-4" style={{ maxHeight: '100vh', overflow: 'hidden' }}>
      {/* Controls Panel */}
      <aside className="w-full lg:w-1/3 lg:max-w-md bg-gray-800 rounded-2xl p-6 flex flex-col gap-4 shadow-2xl overflow-y-auto">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-500">{UI_TEXTS.title}</h1>
          <p className="text-gray-400 mt-2">{UI_TEXTS.subtitle}</p>
        </div>

        <div className="grid grid-cols-2 gap-2 bg-gray-700 p-1 rounded-lg">
          <TabButton active={mode === 'text-to-image'} onClick={() => setMode('text-to-image')}>
            {UI_TEXTS.tabTextToImage}
          </TabButton>
          <TabButton active={mode === 'image-to-image'} onClick={() => setMode('image-to-image')}>
            {UI_TEXTS.tabImageToImage}
          </TabButton>
        </div>

        <div className="flex-grow flex flex-col gap-4">
          <textarea
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            placeholder={UI_TEXTS.promptPlaceholder}
            className="w-full h-28 p-3 bg-gray-700 border-2 border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-300 resize-none"
          />

          {mode === 'text-to-image' ? (
            <>
              {optionKeysInOrder.map((key) => {
                const optionKey = key as TextToImageOptionKey;
                if(optionKey === 'gameGenre' && options.purpose !== 'game design') return null;
                return (
                  <SelectInput
                    key={optionKey}
                    label={TEXT_TO_IMAGE_OPTIONS[optionKey]?.label || GAME_GENRE_OPTIONS.label}
                    value={options[optionKey]}
                    options={TEXT_TO_IMAGE_OPTIONS[optionKey]?.options || GAME_GENRE_OPTIONS.options}
                    onChange={(e) => handleOptionChange(optionKey, e.target.value)}
                  />
                );
              })}
              {options.purpose === 'game design' && (
                 <SelectInput
                    key='gameGenre'
                    label={GAME_GENRE_OPTIONS.label}
                    value={options.gameGenre}
                    options={GAME_GENRE_OPTIONS.options}
                    onChange={(e) => handleOptionChange('gameGenre', e.target.value)}
                  />
              )}
            </>
          ) : (
            <ImageUpload onUpload={handleImageUpload} uploadedFile={uploadedImage?.file ?? null} />
          )}
        </div>

        {/* Gift Code */}
        <div className="flex flex-col gap-2">
            <label className="text-sm font-medium text-gray-300 flex items-center gap-2"><GiftIcon /> {UI_TEXTS.giftCodeTitle}</label>
            <div className="flex gap-2">
                <input 
                    type="text" 
                    value={giftCode}
                    onChange={(e) => setGiftCode(e.target.value)}
                    placeholder={UI_TEXTS.giftCodePlaceholder}
                    className="flex-grow p-2 bg-gray-700 border-2 border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                />
                <button onClick={handleRedeemCode} className="px-4 py-2 bg-purple-600 rounded-lg font-semibold hover:bg-purple-700 transition">{UI_TEXTS.giftCodeButton}</button>
            </div>
            {giftCodeMessage.text && (
              <p className={`text-sm ${giftCodeMessage.type === 'success' ? 'text-green-400' : 'text-red-400'}`}>
                {giftCodeMessage.text}
              </p>
            )}
        </div>

        <div className="text-center text-gray-400 text-sm">
            {UI_TEXTS.generationsRemaining}: <span className="font-bold text-white">{remainingGenerations()}</span>
        </div>

        <button
          onClick={handleSubmit}
          disabled={isSubmitDisabled || !canGenerate()}
          className="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-3 px-4 rounded-lg hover:from-purple-600 hover:to-pink-600 transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
        >
          <SparklesIcon />
          {isLoading ? UI_TEXTS.buttonGenerating : UI_TEXTS.buttonGenerate}
        </button>
      </aside>

      {/* Display Panel */}
      <main className="w-full lg:w-2/3 bg-gray-800 rounded-2xl p-6 flex flex-col gap-4 shadow-2xl overflow-hidden">
        <div className="flex-grow flex items-center justify-center relative rounded-lg bg-gray-900/50">
            {isLoading && <Spinner />}
            {error && !isLoading && (
              <div className="text-center text-red-400 flex flex-col items-center gap-4">
                <AlertTriangleIcon />
                <p className="font-semibold">{UI_TEXTS.errorTitle}</p>
                <p>{error}</p>
              </div>
            )}
            {!isLoading && !error && generatedImage && (
              <img src={generatedImage} alt="Generated" className="max-w-full max-h-full object-contain rounded-lg shadow-lg" />
            )}
            {!isLoading && !error && !generatedImage && (
              <div className="text-center text-gray-500 flex flex-col items-center gap-4">
                <ImageIcon />
                <h2 className="text-xl font-semibold">{UI_TEXTS.placeholderTitle}</h2>
                <p className="max-w-sm">{UI_TEXTS.placeholderSubtitle}</p>
              </div>
            )}
        </div>

        {/* History Panel */}
        <div className="flex-shrink-0">
          <h3 className="text-lg font-semibold mb-2 flex items-center gap-2 text-gray-300"><HistoryIcon /> {UI_TEXTS.historyTitle}</h3>
          {history.length > 0 ? (
            <div className="flex gap-3 overflow-x-auto pb-2">
              {history.map(item => (
                <img 
                  key={item.id}
                  src={item.imageUrl} 
                  alt={item.prompt} 
                  onClick={() => setGeneratedImage(item.imageUrl)}
                  className="w-24 h-24 object-cover rounded-md cursor-pointer border-2 border-transparent hover:border-purple-500 transition-all"
                />
              ))}
            </div>
          ) : (
             <p className="text-sm text-gray-500">{UI_TEXTS.historyEmpty}</p>
          )}
        </div>
      </main>
    </div>
  );
}
